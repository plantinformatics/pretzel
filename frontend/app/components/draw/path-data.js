import { computed } from '@ember/object';
import Component from '@ember/component';
import { inject as service } from '@ember/service';


import AxisEvents from '../../utils/draw/axis-events';
import { stacks, Stacked } from '../../utils/stacks';
import {
  selectAxis,
  blockAdjKeyFn,
  blockAdjEltId,
  foregroundSelector,
  selectBlockAdj
} from '../../utils/draw/stacksAxes';

import {
  AxisChrName,
 } from '../../utils/utility-chromosome';

import { PathDataUtils } from '../../utils/draw/path-data';

//------------------------------------------------------------------------------

/* global d3 */

/*----------------------------------------------------------------------------*/

/** Used for CSS selectors targeting <g> and <path>-s generated by this component. */
const className = "block-feature-path";

let trace_path = 1;


/*----------------------------------------------------------------------------*/

/** This component supports the general case of alignment between two blocks (on adjacent axes).
 * If the feature names on the 2 blocks is the same, we term this a direct alignment.
 * Otherwise the aligment may be established via some form of alias, and the
 * feature names on the 2 blocks may be different.
 *
 * The component's focus (scope of responsibility) is the data associated with
 * the path, and attributes derived from that.  i.e. key and attr functions for
 * <path>-s can use the component's CFs, including stroke - path colour, and
 * this component will absorb functions flagged with 'paths-classes' in
 * draw-map.js;   path hover text & popovers;
 * The svg render of the <path> is be done by the parent component via d3 .data() join.
 *
 * @param ffaa  i.e. feature0, feature1, block0, block1
 */
export default Component.extend({
  /** 
   * Related : unique_1_1_mapping, pathDataInG
   */

  feature2BlockId(i) {
    let fieldName = 'feature' + i,
    feature = this.get(fieldName),
    blockId = feature.get ? feature.get('blockId.id') : feature.blockId;
    return blockId;
  },

  /** currently feature{0,1} are in this component, and they reference their respective blocks.
   * May instead use models/draw/path-data for the data attributes, or a non-store object.
   */
  blockId0 : computed('feature0.blockId.id', function () { return this.feature2BlockId(0); }),
  blockId1 : computed('feature1.blockId.id', function () { return this.feature2BlockId(1); }),


    /** Determine the svg <path> data attribute for this component.
     * @param ffaa  [feature0, feature1, a0, a1]
     */
  // pathU needs to depend also on the positions of the stacked axes, which will
  // be possible when stacks / axes are components, then this can be a computed function.
  /** In this commit, there is an instance of this component for each path, and `this` references the data;
   * alternately the componenent can be a singleton or library, with the model data passed as argument pathData.
   * If the component is per-path with a separate model path-data, then pathData will be an attribute of the component.
   * @param pathData the models/draw/path-data instance, contains the data of the path.
   * attributes : blockId0, blockId1, feature0, feature1
   */
  pathU : /*Ember.computed('feature0', 'feature1', 'block0', 'block1',*/ function() {
    let pathData = this;
    // based on draw-map.js : pathU(), pathUg(); this is equivalent and can replace those functions. (related : dataOfPath()).

    let p = [];
    const axes = ['0', '1'].map((fi) => pathData.get('feature' + fi + '.blockId.axis1d'));
    const pathDataUtils = PathDataUtils(stacks.oa);
    p[0] = pathDataUtils.patham(axes[0], axes[1], pathData.get('feature0'), pathData.get('feature1'));
    if (trace_path > 1) {
      const blockNames = ['0', '1'].map((fi) => pathData.get('feature' + fi + '.blockId.brushName'));
      console.log(
        "pathU",
        blockNames,
        pathData.feature0, pathData.feature1, p[0]);
    }
    return p;
  }/*)*/,

  /** Used to filter a selection of paths to find those whose blocks both have axes or not.
   * Depends on .block0 and .block1, but also on stacks, so this can be a CF
   * when stacks & axes are Components.
   * @param pathData the models/draw/path-data instance, contains the data of the path.
   */
  blocksHaveAxes() {
    let pathData = this;
    let getAxis = Stacked.getAxis;
    let block0 = pathData.get('blockId0'),
    block1 = pathData.get('blockId1');
    let haveAxes =
      (pathData.get('feature0.blockId.isViewed') || getAxis(block0)) &&
      (pathData.get('feature1.blockId.isViewed') || getAxis(block1));
    return haveAxes;
  }


});
