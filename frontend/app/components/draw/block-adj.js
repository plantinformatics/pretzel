import { getOwner } from '@ember/application';
import { allSettled, Promise } from 'rsvp';
import { A } from '@ember/array';
import { computed, get } from '@ember/object';
import { alias } from '@ember/object/computed';
import Evented from '@ember/object/evented';
import Component from '@ember/component';
import { inject as service } from '@ember/service';
import { debounce, throttle, later, next, once as run_once } from '@ember/runloop';
import { task, timeout, didCancel } from 'ember-concurrency';

import { isEqual } from 'lodash/lang';

import AxisEvents from '../../utils/draw/axis-events';
import { stacks, Stacked } from '../../utils/stacks';
import {
  selectAxis,
  blockAdjKeyFn,
  blockAdjEltId,
  featureEltIdPrefix,
  featureNameClass,
  foregroundSelector,
  selectBlockAdj
} from '../../utils/draw/stacksAxes';
import {
  targetNPaths,
  pathsFilter,
  pathsFilterSmooth
} from '../../utils/draw/paths-filter';
import { intervalSize } from  '../../utils/interval-calcs';
import {
  pathsResultTypes,
  pathsApiResultType,
  flowNames,
  resultBlockIds,
  syntenyBlocksOfFeature,
  pathsOfFeature,
  locationPairKeyFn
} from '../../utils/paths-api';
import { PathInfo } from '../../utils/draw/path-info';


import { getTransform, transform2Css } from '../../utils/draw/direct-linear-transform';
import { thenOrNow } from '../../utils/common/promises';

/* global d3 */



/*----------------------------------------------------------------------------*/

/** Used for CSS selectors targeting <g> and <path>-s generated by this component. */
const className = "blockAdj";
const CompName = 'components/axis-ticks-selected';

const dLog = console.debug;
const trace_blockAdj = 0;
const trace_pathTransform = 2;

/** select use of pathIsColinear() or pathIsSyntenic() - different algorithms
 * for the purpose of thresholding the synteny of display paths.
 */
const useColinear = false;

const
sortedEnd = 0,
otherEnd = 1 - sortedEnd;


/*----------------------------------------------------------------------------*/
/* milliseconds duration of transitions in which alignment <path>-s between
 * features are drawn / changed, in particular the d attribute.
 * Match with time used by draw-map.js : zoom() and resetZoom() : 750.
 * also @see   dragTransitionTime and axisTickTransitionTime.
 * @see featureTrackTransitionTime
 */
const pathTransitionTime = 750;

/** Used for d3 attribute functions - return the datum of the element. */
function datumIdent(d) { return d; }

/** select the g.direct and g.alias within g.foreground > g.progress.
 * @see flowNames[]
 * @param flowName  undefined, or an element of flowNames[]
 */
function progressGroupsSelect(flowName) {
  /** if flowName is undefined, then select g.direct and g.alias.  refn flowNames[] */
  let classSelector = flowName ? '.' + flowName : '',
  selector = foregroundSelector + '> g.progress > g' + classSelector,
  g = d3.selectAll(selector);
  return g;
}



/*----------------------------------------------------------------------------*/

/**
 * @param blockAdj  [blockId0, blockId1]
 * @param drawMap for Evented - stack events
 */
export default Component.extend(Evented, AxisEvents, {
  /** AxisEvents is used to receive axis stacking and resize events.
   *  Evented may be used in future to propagate events to components rendered within block-adj.
   */
  store: service(),
  pathsP : service('data/paths-progressive'),
  flowsService: service('data/flows-collate'),
  block: service('data/block'),
  axisZoom : service('data/axis-zoom'),
  queryParams: service('query-params'),
  controls : service(),


  needs: ['component:draw/path-data'],

  controlsView : alias('controls.view'),
  graphFrame : alias('drawMap.oa.graphFrame'),

  /** counters to debounce CFs */
  heightChanged : 0,
  axisStackChangedCount : 0,

  /** The DB IDs of the blocks which this block-adj aligns.
      * array[2] of blockId
      */
  blockAdjId : alias('blockAdj.blockAdjId'),
  // blockAdj.id is the same values in a string form, separated by '_'
/*  ('blockAdj', function () {
    let blockAdj = this.get('blockAdj'),
    blockAdjId = blockAdj.get('blockAdjId');
    dLog(blockAdj, 'blockAdjId', blockAdjId);
    return blockAdjId;
  }),
*/
  axes :  alias('blockAdj.axes'),

  /** comment in services/data/block.js explains context of urlOptions
   */
  parsedOptions : alias('queryParams.urlOptions'),

  pathsDensityParams : alias('pathsP.pathsDensityParams'),
  isComplete() { return this.blockAdj.isComplete(); },
  pathsResultLength : computed(
    'blockAdj.pathsResultLengthThrottled', 'pathsAliasesResultLength',
    'blockAdj.filterPathSynteny',
    'pathsDensityParams.{densityFactor,nSamples,nFeatures}',
    'controlsView.{pathGradientUpper,pathGradient,pathNeighbours}',
    function () {
      /** this CP may be evaluated before the first didRender(), which does
       * drawGroup{Container,}(); waiting for next render so that drawCurrent()
       * has <g> to render into.
       */
      next(() => {
        if (this.isDestroying) { return; }
        /** it is possible (currently) for this CP to be evaluated after one end
         * (block) of a block-adj to become un-viewed and before the block-adj
         * is destroyed.  This check detects and handles that case.
         */
        if (this.isComplete()) {
          let
          length = this.drawCurrent(pathsResultTypes.direct),
          pathsAliasesLength = this.get('pathsAliasesResultLength');
          // return length;
        }
      });
  }),
  /** Used in paths{,Aliases}ResultLength().
   */
  drawCurrent : function(prType) {
    let
    /** e.g. 'pathsResult' or 'pathsAliasesResult'
     * Use the filtered form of the API result.
     */
    pathsResult = this.get('blockAdj.' + prType.fieldName + 'Filtered'),
    fnName = prType.fieldName + 'Length',
    length = pathsResult && pathsResult.length;
    dLog('drawCurrent', fnName, this, length);
    if (length) {
      this.get('drawCurrentTask').perform(prType, pathsResult)
        .catch((error) => {
          // Recognise if the given task error is a TaskCancelation.
          if (! didCancel(error)) {
            dLog('drawCurrentTask taskInstance.catch', this.blockAdjId, error);
            throw error;
          }
        });
    } else if (! this.get('blockAdj.receivedAll')[prType.typeName]) {
      /** drawCurrent() will do this if more paths required.
       *  If 0 paths then request paths.  */
      this.incrementProperty('blockAdj.pathsRequestCount');
    }

    // length returned by paths{,Aliases}ResultLength is currently just used in logging, not functional.
    return length;
  },

  /*--------------------------------------------------------------------------*/

  /** Scale positions of features within their respective axis
   * to the interval [0,1],
   * to 3 decimal places (more or less decimal places would determine the level of "binning" happening implicitly)
   * @param yRange  limits of block containing feature (absolute, not zoomed).
   *
   * @desc  Context :
   * From : #250 : Slider to control co-linearity of paths to display 
   * When aligning chromosomes it is common for paths to cross-over, sometimes from one end of the chromosome to the other. For example:
   *   image : https://user-images.githubusercontent.com/20571319/124571237-f445cb80-de8a-11eb-9562-4de45654ce4d.png
   * A small number of paths here stand out as outliers - their position in the left-side axis is very different, relatively, to that in the right-side axis.
   * These could be filtered out with a slider between 0 and 1 which defines the maximum variance allowed in the alignment.
   * A brief sketch of how this will work:
   * -  The slider is set to value S
   * -  Only feature pairs x, y are displayed when scaled_pos(x) - S <= scaled_pos(y) <= scaled_pos(x) + S
   * -  S = 1 displays all paths, S = 0 would show only those paths in the exact same relative position
   * -  Setting S = 0.1 or so would remove the cross-over paths in the example above.
   *
   * A small extension would be to also control whether S defines a maximum (as in the above) or a minimum. The latter case would allow the immediate display of non-co-linear paths only - ie: for example, if the features are genes, only those genes that have moved a relatively large amount.
   */
  scaled_pos(featureLimits, y) {
    let
    range = featureLimits[1] - featureLimits[0],
    yScaled = (y - featureLimits[0]) / range;
    return yScaled;
  },

  /*--------------------------------------------------------------------------*/

  /**
   * @return promise of completion of rendering and transitions
   */
  drawCurrentTask : task(function * (prType, pathsResult) {
      let promise;
      let pathsDensityParams = this.get('pathsDensityParams'),
      axes = this.get('axes'),
      // axesDomains = this.get('blockAdj.axesDomains'),
      // Use the current zoom domain, not the overall domain, which is b.axis.domain.
      blockDomains =
        axes.mapBy('blocks')
        .reduce(function (bd, bb) {
          /* draw_orig : axes[].blocks[] were Block, now BlockAxisView / block-axis-view,
           * so b.axis.axis1d is now b.axis
           */
          // if axis is deleted, blocks are un-viewed, i.e. b.block.get('isViewed') is false, and b.axis === undefined
          bb.forEach(function (b) { bd[b.axisName] = b.axis?.get('domain'); }); return bd; }, {}),
      axesRanges = axes.map((a) => a.yRange()),
      axisLengthPx = Math.max.apply(null, axesRanges),
      nPaths = targetNPaths(pathsDensityParams, axisLengthPx);
      // handle b.axis === undefined (block has been un-viewed)
      if (Object.values(blockDomains).indexOf(undefined) !== -1) {
        return Promise.resolve();
      }
    /** if either domain is 0-length, don't apply pathIsColinear() because
     * corresonding sp[i] will be NaN */
    let zeroDomain = Object.values(blockDomains).any((d) => d[1] === d[0]);
    /** this is the number of paths in scope, which is relevant to the
     * check for incrementing pathsRequestCount. */
    let pathsResult_length = pathsResult.length;
    const filterPathSynteny = this.get('blockAdj.filterPathSynteny');
        let pathGradient = this.get('controlsView.pathGradient'),
            pathGradientUpper = this.get('controlsView.pathGradientUpper');
        dLog('pathGradient', pathGradient, pathGradientUpper, pathsResult.length);
        const pathEndOrder = this.pathEndOrder(pathsResult);
    /** Used by pathIsSyntenic() : neighbourDistance() */
    let domainSizes = this.axesDomainSizes();
    if (filterPathSynteny && ! useColinear && pathsResult.length) {
      // pathGradient = this.gradientThresholdToAxis(pathGradient);
      /* gradientThresholdToAxis() scales pathGradient up by intervalSize(domain of otherEnd),
       * which does not handle a block-adj which a large difference between its 2 axis lengths.
       * The pathIsSyntenic() comment explains further.
       */
      // domainSizes is used (by pathIsSyntenic()) in this case.
    }

      if (filterPathSynteny && ! zeroDomain && pathsResult.length) {
        pathsResult = pathsResult.filter(
          ! useColinear ?
            (p) => this.pathIsSyntenic(
              p, pathGradient, this.get('controlsView.pathGradientUpper'), pathEndOrder, domainSizes) :
          (p) => /*this.*/pathIsColinear(
            p, pathGradient, pathGradientUpper, this.scaled_pos));
        /**
         * @param p path-data - API result for paths request
         * @param pathGradient  threshold
         * @param pathGradientUpper true means use pathGradient threshold as an upper limit.
         */
        function pathIsColinear(p, pathGradient, pathGradientUpper, scaled_pos) {
          let
          features = this.pathFeatures(p),
          limits = features.map((f) => f.get('blockId.featureLimits')),
          /** if any of the limits are undefined (not yet known), don't filter. */
          ok = limits.any((l) => !l);
          if (! ok) {
            let
            /** feature .value may be an interval;  only value[0] is used here. */
            y = features.map((f) => f.get('value.0')),
            /** values identified in the spec as [scaled_pos(x), scaled_pos(y)]  */
            sp = y.map((yi, i) => /*this.*/scaled_pos(limits[i], yi)),
            S = pathGradient;
            ok = (sp[0] - S) <= sp[1] && (sp[1] <= sp[0] + S);
            if (! pathGradientUpper) {
              ok = ! ok;
            }
          }
          return ok;
        };
        dLog('drawCurrentTask after pathGradient pathsResult.length', pathsResult.length);
      }
      const s_p = this.scaled_pos;

      if (pathsResult_length < nPaths) {
        /* to satisfy the required nPaths, trigger a new request. */
        this.incrementProperty('blockAdj.pathsRequestCount');
      } else if (pathsResult.length > nPaths) {
        /** Filtering should be smooth, so filtering paths for render keeps the
         * currently-drawn paths where possible, instead of choosing paths for
         * each render independently.
         * When zooming in, retain the paths which are currently drawn and add
         * more as needed; when zooming out, filter the current paths according
         * to the reduction of zoomedDomain, and add new paths in the region
         * (previousDomain - new domain), to meet the desired number.
         */
        let
          scope = this.get('scope' + prType.typeName),
        currentScope = {blockDomains, pathsDensityParams, nPaths};
        /** pathsFilterSmooth() tends to suppress the effect of pathGradient filter, so use one or the other. */
        let
            pathGradientFilterEnabled = (pathGradient !== 0) && (pathGradient !== 1);
        if (! scope || ! pathGradientFilterEnabled) {
          /* first call, scope is not yet defined, there are no existing paths,
           * so use pathsFilter() instead of pathsFilterSmooth() */
          pathsResult = pathsFilter(prType, pathsResult, blockDomains, nPaths);
          scope = this.set('scope' + prType.typeName, A());
          scope[0] = currentScope;
          let shown = this.set('shown' + prType.typeName, new Set());
          pathsResult.forEach((p) => shown.add(p));
        } else {
          let shown = this.get('shown' + prType.typeName);
          scope[1] = currentScope;
          const shownArray = (shown instanceof Set) ? Array.from(shown.values()) : shown;
          const pathEndOrder = this.pathEndOrder(shownArray);
          if (filterPathSynteny && shown.length) {
            shown = shown.filter(
              ! useColinear ?
              (p) => this.pathIsSyntenic(
                p, pathGradient, this.get('controlsView.pathGradientUpper'), pathEndOrder, domainSizes) :
              (p) => /*this.*/pathIsColinear(
                p, pathGradient, this.get('controlsView.pathGradientUpper'), this.scaled_pos));
          }
          pathsResult = pathsFilterSmooth(prType, pathsResult, scope, shown);
          scope.removeAt(0);
        }
      }
      /* The calling CPs paths{,Aliases}ResultLength() are called before didRender
       * and hence before drawGroup{,Container}().   .draw() uses the <g>-s they
       * maintain; so may need defer until end of run loop, but it is likely a
       * later call to this function will be after those are created.
       */
    promise = this.draw(/*pathsApiResultType*/ prType, pathsResult);
    return promise;
  }).keepLatest(),

  /** @return the intervalSize of the 2 axes of this block-adj. */
  axesDomainSizes() {
    /** related : gradientThresholdToAxis(). */
    const
    domains = this.blockAdj.axesDomains,
    lengths = domains.map((d) => intervalSize(d));
    return lengths;
  },

  /** Convert pathGradient, which is [0, 1] to be proportional to axis length.
   */
  gradientThresholdToAxis(pathGradient) {
    const
    domain = this.blockAdj.axesDomains[otherEnd],
    length = pathGradient * intervalSize(domain);
    /** equivalent to axesDomains[] : this.pathFeatures(pathsResult[0]).mapBy('blockId.id').map((blockId) => blockDomains[blockId])
*/
    return length;
  },

  /** Lookup the endpoint feature pair of the path.
   * Express them in the same order as this.blockAdj.blockAdjId,
   * i.e. for the result features[end] where end is [0,1] 
   * features[end].get('blockId.id') === this.blockAdj.blockAdjId[end]
   * (equivalent : .block{0,1}.get('id') or  .blockId{0,1})
   * @param p path, from path request results, not path-data
   * @return [feature0, feature1]
   */
  pathFeatures(p) {
    /** result format is different for direct and aliases requests;
     * for either case, collate as an array the endpoint features of the path.
     * Can use : [0,1].map((i) => prType.blocksFeatures(e, i)[0])
     * Each alignment[].repeats may have multiple features;  only the first is considered here.
     */
    const
    features =
      p.alignment ? p.alignment.map((a) => a.repeats.features[0]) :
      [p.featureAObj, p.featureBObj],
    /** can compare either end */
    end = sortedEnd,
    parallel = p.alignment ? 
      (p.alignment[end].blockId === this.blockAdj.blockAdjId[end]) :
      (features[end].get('blockId.id') === this.blockAdj.blockAdjId[end]);
    if (! parallel) {
      // swap
      [features[1], features[0]] = [features[0], features[1]];
    }
    return features;
  },
  pathFeature(p, end) {
    return this.pathFeatures(p)[end];
  },

  /**
looking at the currently displayed paths in a block_adj :
  for the 2 end blocks of the block_adj, sort the endpoint positions of the paths, i.e. Features in the block which are in paths, sorted by position, enabling each path to look up the ordinal position of each of its 2 endpoints.
  for each path : calculate ordinal position of its 2 endpoints, call these o1, o2
    compare (o2-o1) against the (GUI slider) threshold
 *
 * Change : just sort one end (block) of the block_adj (adjacent pair) and threshold the distance to potential neighbour at the other end. 
 * @param shown features from pathsResult which are to be shown
 * @return {sorted, order}
 *   sorted : paths sorted in order of the 0 end feature value; 
 *   order : map from paths to index within sorted.
 *
 * To check the result, display in web inspector console :
 *   result pathEndOrder.sorted.mapBy('0.alignment.0.repeats.features.0.value.0')
 *   result pathEndOrder.sorted.map((sp) => pathEndOrder.order.get(sp[0]))
 */
  pathEndOrder(shown) {
    const
    fnName = 'pathEndOrder',
    shownFeatures = shown.map(this.pathFeatures.bind(this)),
    /** could sort both ends; instead try a proximity threshold on the other end */
    sorted = shownFeatures.map((featurePair, i) => {
      const y = featurePair[sortedEnd].get('value.0');
      // {pathData : shown[i], featurePair, y}
      return [shown[i], y];
    })
      .sortBy('1')
    // i is index within sorted
      .map(([path, y], i) => [path, i, y]),
    /** after sort, omit y to make orderd pairs for Map(). leaving .y in .sorted just for devel checking. */
    /** map from path-data to end order */
    order = new Map(sorted
      .map((piy) => piy.slice(0, 2)) );
    if (trace_blockAdj > 2) {
      dLog(fnName, sorted, order, shown);
    }
    return {shown, sorted, order};
  },
  /** Alternative to pathIsColinear()
   *
   * A block-adj may have a large difference between its 2 axis lengths,
   * e.g.  a GM axis (centiMorgans : ~100) and a physical reference axis
   * (base pairs : ~1e8).
   *
   * axesDomainSizes() is passed to neighbourDistance() which scales the
   * distance between path and neighbour at each end down by domainSizes[end],
   * so that the 2 distances are proportionate and can be combined as a
   * Euclidean distance, and the average distance of neighbours within +/-
   * offset can be compared against pathGradient.
   *
   * @param threshold pathGradient
   * @param pathEndOrder  result of pathEndOrder()
   * @param domainSizes intervalSize of the 2 axes of this block-adj. result of axesDomainSizes().
   */
  pathIsSyntenic(p, threshold, pathGradientUpper, pathEndOrder, domainSizes) {
    let okCount = 0;
    let reasons = [];
    const neighbourScope = this.get('controlsView.pathNeighbours') || 3;
    /** sum and count of distances added. */
    let sum = 0, count = 0;
    for (let offset=1; offset <= neighbourScope; offset++)
    {
      for (let sign=1; sign >= -1; sign -= 2) {
        let distance = this.neighbourDistance(pathGradientUpper, pathEndOrder, domainSizes, sign * offset, p, reasons);
        if (distance !== undefined) {
          sum += distance;
          count++;
        }
      }
    }
    const average = sum / count;
    let ok = average < threshold;
    if (! pathGradientUpper) {
      ok = ! ok;
    }

    if (ok) {
      p[Symbol.for('syntenyEvidence')] = reasons;
    }
    return ok;
  },
  /** Calculate the distance from path p to the neighbour identified by offset.
   * For distance : treat the 2 axes as perpendicular, and calculate Euclidean distance.
   * @param pathEndOrder  result of pathEndOrder()
   * @param domainSizes intervalSize of the 2 axes of this block-adj. result of axesDomainSizes().
   * @param offset current values are +/- 1
   * @param evidence gather data underlying the calculation
   * @return distance, or undefined if the given offset is out of range
   *
   * @desc
   * In 80f96096 this function was named neighbourIsClose() and calculated the
   * distance between the opposite endpoints of p and neighbour, and returned
   * true if within threshold.  This assumed that neighbours are close; this
   * change aims to ignore support from distant neighbours.
   */
  neighbourDistance(pathGradientUpper, pathEndOrder, domainSizes, offset, p, evidence) {
    const
    /** index of 1 end of path in pathEndOrder.sorted */
    endIndex = pathEndOrder.order.get(p),
    neighbourIndex = endIndex + offset;
    let distance;
    if ((neighbourIndex < 0) || (neighbourIndex >= pathEndOrder.sorted.length)) {
      // result is undefined
    } else {
      const
      /** neighbour refers to the path which is adjacent by offset at one end;
       * this function determines if it is a neighbour at the other end.
       *
       * pathEndOrder.sorted[][0] are the path-data, corresponding to pathEndOrder.shown[]
       */
      neighbour = pathEndOrder.sorted[neighbourIndex][0],
      neighbourFeatures = this.pathFeatures(neighbour),
      neighbourValue = neighbourFeatures[otherEnd].value[0],
      pathFeatures = this.pathFeatures(p),
      pathEndValue = pathFeatures[otherEnd].value[0];
      /** the 2 components can be adjusted relative to their axis. */
      distance = Math.sqrt(
        ((neighbourValue - pathEndValue) / domainSizes[otherEnd]) ** 2 + 
          ((neighbourFeatures[sortedEnd].value[0] - pathFeatures[sortedEnd].value[0]) / domainSizes[sortedEnd]) **2);

      if (trace_blockAdj > 2) {
        dLog(distance, endIndex, offset, pathEndValue, neighbourValue, pathFeatures, neighbourFeatures);
      }
      const
      data = 
        {endIndex, offset, neighbourIndex, neighbour, neighbourFeatures,
         p, pathFeatures, pathEndValue, neighbourValue, distance};
      evidence.push(data);
    }
    return distance;
  },
  /* are the path's features' orders contiguous with neighbours
   * paths which neighbour path end0, are they (>0) neighbours on path end1
   * path.features[end0], neighbouring features n[2], their paths 
   * featurePaths.get(n[*]) -> np[2], np[*][end1] -> orders
   * or :  delta gradient with n neighbours (either end) within threshold
   * or similar, use feature value of other end in comparison instead of gradient
  */
  orderDelta(pathEnds, feature, end) {
    const
    orders = features.map((f, end) => pathEnds.orders[end].get(f)),
    orderDelta = orders[1] - orders[0];
  },


  pathsAliasesResultLength : computed(
    'blockAdj.pathsAliasesResultLengthThrottled', 'paths.alias.[]',
    'blockAdj.filterPathSynteny',
    'pathsDensityParams.{densityFactor,nSamples,nFeatures}',
    'controlsView.{pathGradientUpper,pathGradient,pathNeighbours}',
    function () {
      /** the comments in pathsResultLength re. next and isComplete apply here also. */
      next(() => {
        if (this.isDestroying) { return; }
        if (this.isComplete()) {
          /* pathsAliasesResult is in a different form to pathsResult; passing it to
           * draw() requires some mapping, which is abstracted in 
           * pathsResultType e.g. pathsResultTypes.{direct,alias}
           */
          pathsApiResultType.flowName = pathsResultTypes.alias.flowName;
          pathsApiResultType.typeName ||= pathsResultTypes.alias.flowName;
          pathsApiResultType.fieldName = pathsResultTypes.alias.fieldName;

          let
          pathsAliasesLength = this.drawCurrent(pathsApiResultType /*pathsResultTypes.alias*/);

          // return pathsAliasesLength;
        }
      });
  }),
  paths : alias('blockAdj.paths'),
  /** Trigger paths request - side-effect. In the streaming case, result when
   * the stream ends is [], so paths{,Aliases}Result are used instead of the
   * result of this promise.
   */
  pathsRequest : computed('blockAdj.pathsResultLengthDebounced', function () {
    let pathsP = this.get('blockAdj.paths');
    dLog('blockAdj.paths', pathsP);
    function thenLength(p) { return ! p ? 0 : thenOrNow(p, (a) => get(a, 'length')); }
    let lengthSumP = thenLength(pathsP.direct) + thenLength(pathsP.alias);
    return lengthSumP;
  }),
  /** Draw all new paths received - unfiltered by pathsDensityParams.
   * The above paths{,Aliases}ResultLength(), which are currently used, ensure
   * the required renders, so this can be dropped if there is not likely to be a
   * need for showing unfiltered paths.
   */
  pathsEffect : computed(
    // the debugger will evaluate this CP if this dependency is enabled.
    // 'blockAdj.paths.{direct,alias}.[]',
    function () {
    /** in the case of pathsViaStream, this promise will resolve with [] instead of the result -
     * blockAdj.pathsResult is passed to draw() instead.  */
    let pathsP = this.get('blockAdj.paths');
    dLog('blockAdj.paths', pathsP);
    thenOrNow(pathsP, (result) => {
      dLog('blockAdj.paths', result);
      flowNames.forEach(flowName => {
        if (result[flowName])
          thenOrNow(result[flowName], (paths) => {
            /** pathsApiResultType could be identified as
             * pathsResultTypes.pathsApi; it is an input format which may be used
             * in multiple flows, so possibly .flowName should be separate from
             * pathsResultTypes[].
             */
            let pathsResultType = paths.length && paths[0].featureAObj ?
              pathsApiResultType /*pathsResultTypes.pathsApi*/ : pathsResultTypes[flowName];
            dLog('blockAdj.paths length', paths && paths.length, pathsResultType);
            if (paths && paths.length)
              throttle(this, this.draw, pathsResultType, paths, this.get('controlsView.throttleTime'), false);
          });
      });
    });

    if (false) {
    /** .direct and.alias are defined by the result of pathsP, not by pathsP, so
     * this would need to change; no purpose for this yet. */
    let resultP = (pathsP.direct && pathsP.alias) ?
    allSettled([pathsP.direct, pathsP.alias])
      : (pathsP.direct || pathsP.alias);
    }
    return pathsP;
  }),

  /*--------------------------------------------------------------------------*/

  getAxes() {
    let
    /* factor getAxes() out of blockAdj.axes,  getAxis() out of block, separating
     * from .referenceBlock. */
    axesP = stacks.axesP,
    axes = this.get('blockAdj.blocks').map((block) => axesP[block.get('id')]);
    /** this is equivalent to the above lookup via axesP, but this is causing delay - slows down to throttled time. */
    // axes = this.get('axes');
    return axes;
  },

  /** @return scales of blocks's axes, parallel to .blocks[]
   */
  previousScales: computed(function () {
    /** no dependencies, called once when first used. */ 
    return {};
  }),
  scaleInvert(y) {
    let r = y.range();
    y.range([r[1], r[0]]);
    return y;
  },

  zoomedDomainsEffect : computed(
    'blockAdj.axes1d.{0,1}.zoomedDomain.{0,1}',
    'blockAdj.zoomedDomains.{0,1}',
    function () {
      /** currently depend on 'blockAdj.zoomedDomains.{0,1}', and clear the
       * transform when isEqual(domains, throttled); could instead do that in updatePathsPosition().
       */
      /** if no zoomedDomain then use axis1d .blocksDomain, as in 
       * axis-1d:domain(), but that depends on -Throttled
       */
      let
      axes1d = this.get('blockAdj.axes1d'),
      domains = axes1d.map(
        (axis1d) => axis1d.get('zoomedDomain') || axis1d.get('blocksDomain')),
      throttled = axes1d.mapBy('domain');
      if (trace_pathTransform > 1)
        dLog('zoomedDomainsEffect', domains[0], domains[1], throttled[0], throttled[1]);
      let css, vc, transformX;
      let axes = this.getAxes();
      if (isEqual(domains, throttled)) {
        let
        previousScales = this.get('previousScales');
        axes.forEach((a) => previousScales[a.axisName] = /*this.scaleInvert()*/a.y.copy());
      } else {
        let
        /** previous scales of the axes, parallel to blocks[] and axes[].  */
        scales = axes.map((a) => this.get('previousScales')[a.axisName]),

        /** 2 ways to calculate from & to, which should be equivalent :
         * 1. from = whole range; to = the range of the old domain at the new scale
         * 2. to = whole range; from = the range of the new domain at the old scale
         */
        /** also need to take into account stacking and flipped : axes[*].{flipped, position, portion} */
        /* method 1. */
        /** whole range */
        from = axes.map((a) => a.y.range().map((r) => a.yRange() - r)),
        /** current pixel range of throttled  */
        to = /*from; from =*/ throttled.map((d, i) => d.map((y) => (axes[i].yRange() - axes[i].y(y))) );
        
        if (/* method 2. */ true) {
          to = from;
          from = domains.map((d, i) => d.map((y) => (axes[i].yRange() - scales[i](y))) );
        }
        if (trace_pathTransform > 1)
          dLog('zoomedDomainsEffect', from[0], from[1], to[0], to[1]);


        let
        oa = this.get('drawMap.oa'),
        /** scaled x value of each axis, indexed by axisIDs */
        o = oa.o,
        blockIds = axes1d.mapBy('referenceBlock.id'),
        /**  index of the axis which has zoomed since throttled time.  */
        zoomedIndex = domains.findIndex((d, i) => ! isEqual(d, throttled[i])),
        /** horizontal position of each axis. */
        x = blockIds.map((id) => o[id]),
        /** from, to are just the y values.  fromXY, toXY have the x added, in {x, y} format. */
        fromXY = this.yIntervals2XY(from, x, zoomedIndex),
        toXY = this.yIntervals2XY(to, x, zoomedIndex),
        H = getTransform(fromXY, toXY);
        css = transform2Css(H);
        if (trace_pathTransform > 1)
          dLog('zoomedDomainsEffect', x, fromXY, toXY, H, css, o);

        transformX = x[zoomedIndex];

        vc = oa.vc;
      }

      let blockAdjId = this.get('blockAdjId');
      let dpS = progressGroupsSelect(undefined);
      let baS = selectBlockAdj(dpS, blockAdjId);
      /** d3 v3 doesn't recognise matrix3d(), only matrix(); can use d3 .attr when update d3 to v4. */
      // baS.attr('transform', css.transform);
      if (! baS.empty()) {
        let nodes = baS.nodes();
        if (! css) {
          if (trace_pathTransform)
            dLog('zoomedDomainsEffect', nodes[0], nodes);
        }
        let styleTransform = css ? ('transform:' + css.transform) : '';
        nodes.forEach((n) => n.setAttribute('style', styleTransform));
      }
      /** 
       * css['transform-origin'] is just '0 0'
       */
      let transformOrigin = css && css['transform-origin'];
      /* position of top-left corner of svg, which is within div#holder
       * Seems not needed for transform-origin; may need yRange.
       let holder = d3.select('#holder').node();
       if (holder) {
       // e.g. '400 23'
       transformOrigin = '' + holder.offsetLeft + ' ' + holder.offsetTop;
       }
      */
      let
      transformY = (vc ? vc.axisTitleLayout.height : 0),
      verticalTitle = vc && vc.axisTitleLayout && vc.axisTitleLayout.verticalTitle,
      yRange = (vc ? vc.yRange : 0),
      shiftLeft = verticalTitle ? 20 : 0,
      margin = {x : 0/*30 + 5*/, y : 0/*5*/};
      transformOrigin = '' + (shiftLeft + margin.x + (transformX||0)) + ' ' + (margin.y + transformY /*+ yRange*/);
      baS.attr('transform-origin', transformOrigin);

    }),
  /** convert 2 y intervals to an array of 4 {x, y}
   * Express x relative to the axis which is zoomed.
   * @param intervals[i][j]	i is axis index [0..1], j is interval end index [0..1]
   * @param x[i]	i is axis index [0..1]
   * @param zoomedIndex index of the axis which has zoomed since throttled time.
   */
  yIntervals2XY(intervals, x, zoomedIndex) {
    return intervals.map((yrange, i) => yrange.map((y, j) => ({y, x: (i === zoomedIndex)? 0 : x[i] - x[zoomedIndex]}))).flat();
  },

  /*--------------------------------------------------------------------------*/

  isAdjacentToAxis(axisID) {
    let axes = this.get('axes'),
    match = (axes[0].axisName === axisID) || (axes[1].axisName === axisID);
    return match;
  },

  /*--------------------------------------------------------------------------*/

  didRender() {
    this._super(...arguments);
    let pM = this.drawGroupContainer();
    this.drawGroup(pM, true);
  },

  willDestroyElement() {
    // didDestroyElement() would also be OK
    dLog('willDestroyElement', this.get('blockAdjId'));
    let foreground = d3.selectAll(foregroundSelector);
    let pS = foreground
      // delete both g.direct and g.alias
      .selectAll('g > g.progress > g');
    this.drawGroup(pS, false);

    this._super(...arguments);
  },

  /** Give the flow control a handle of the g.progress > g for each flow, so
   * that flow-controls : action toggleVisible -> showVisible() can toggle
   * .hidden on this <g>.
   */
  connectFlowControl(flowName, g) {
    let flowsService = this.get('flowsService'),
    flows = flowsService.get('flows');
    dLog('connectFlowControl', flows, flows[flowName].g, g);
    flows[flowName].g = g;
  },

  /** Render the <g.progress><g.direct> which contains the <g.blockAdj> <g> <path>
   * rendered by this component. */
  drawGroupContainer() {
    let foreground = d3.selectAll(foregroundSelector);
    let ppS = foreground
      .selectAll('g > g.progress')
      .data([1]),
    ppA = ppS
      .enter()
      .append('g')
      .attr('class', 'progress'),
    ppM = ppS.merge(ppA),

    pS = ppM
      .selectAll('g > g.direct, g > g.alias') // @see flowNames[]
      .data(flowNames),
    me = this,
    pA = pS
      .enter()
      .append('g')
      .attr('class', datumIdent)
      .each(function (d, i, g) { dLog(this); me.connectFlowControl(d, d3.select(this)); } ),
    pM = pS.merge(pA);
    if (trace_blockAdj)
      dLog('drawGroupContainer', pS.nodes(), pS.node());
    return pM;
  },
  /** Render the <g.blockAdj> which contains the <g><path>
   * @param pM  selection within which to append <g>; result of drawGroupContainer().
   * @param add  true to draw, false to remove
   */
  drawGroup(pM, add) {

    /* render the <g> for this block-adj */
    let
      blockAdjId = this.get('blockAdjId');

    let groupAddedClass = 'block-adj';
    let id = blockAdjEltId(blockAdjId);
    let gS = pM.selectAll('g' + '#' + id + '.' + className + '.' + groupAddedClass);
    /* could use .data(), given a list of all block adjacencies :
     * .data(flowsService.blockAdjs, blockAdjKeyFn); ... gS.enter() ... */
    if (add && gS.empty()) {
      let gA = pM
        .append('g')
        .datum(blockAdjId)
        .attr('id', blockAdjEltId)
        .attr('class', className + ' ' + groupAddedClass)
      ;
      dLog(gA.nodes(), gA.node(), this);
    }
    else if (! add && ! gS.empty()) {
      dLog('drawGroup remove', gS.nodes(), gS.node(), this);
      gS.remove();
    }
      
  },


  /**
   * @param pathsResultType e.g. pathsResultTypes.{Direct,Aliases}
   * @param paths grouped by features
   * @return promise of completion of rendering and transitions
   */
  draw (pathsResultType, featurePaths) {
    let promise;

    /** for MVP, divert from here featurePaths which are syntenyBlocks.
     * in next version, may filter into a separate CP.
     */
    {
      let oa = this.get('drawMap.oa');
      if (this.get('blockAdj.areSyntenyBlocks')) {
        /** map to : chr1 chr2 g1 undefined g3 undefined id size, i.e. syntenyBlock_2Feature === true; */
        const
        SB_chr1 = 0,
        SB_chr2 = 1,
        SB_g1 = 2,
        SB_g2 = 3,
        SB_g3 = 4,
        SB_g4 = 5,
        SB_ID = 6,
        SB_SIZE = 7;
        let mapFn = syntenyBlocksOfFeature(pathsResultType);
        let addSb = featurePaths
          .map((fp) => {
            let fpm = mapFn(fp);
            if (! fpm.length || (fpm.length > 1)) {
              dLog('syntenyBlocks', fpm);
            }
            /** [f0, f1, blockId0, blockId1] */
            let
            s = fpm[0],
            sbSize = intervalSize(s[0].value) + intervalSize(s[1].value),
            sb = [].concat(s[2], s[3], s[0], undefined, s[1], undefined, s[0].name, sbSize);
            return sb;
          });
        /** rough check for uniqueness - could also check [2].value[1] and [4].value[0]; will use a Map  */
        let filtered = addSb.filter((a) => ! oa.syntenyBlocks.any(
          (o) => (
            (a[SB_ID] === o[SB_ID]) &&
              (a[2].value[0] === o[2].value[0]) &&
              (a[4].value[1] === o[4].value[1]))));
        dLog('draw', addSb.length, filtered.length, oa.syntenyBlocks, 'syntenyBlocks');
        oa.syntenyBlocks = oa.syntenyBlocks.concat(filtered);
        if (addSb.length) {
          let axisApi = this.get('drawMap.oa.axisApi');
          axisApi.updateSyntenyBlocksPosition();
        }
        return Promise.resolve();
      }
    }

    if (featurePaths.length === 0)
      return Promise.resolve();
    pathsResultType.typeCheck(featurePaths[0], true);
    let store = this.get('store');
    /* Enables (via ?options=pathRemoveTransition), animation of <path> removal
     * which is useful to verify paths re-filter.
     * If it was enabled in the general release, the transition can include
     * d=pathU so that paths removed at the edge, when zooming in, move over the
     * edge.
     */
    let pathRemoveTransition = this.get('parsedOptions.pathRemoveTransition');

    /** blockAdjId is also contained in the result featurePaths
     */
    let
      blockAdjId = this.get('blockAdjId');

    /** Looking at just the first result, check the results blockIds match the
     * request blockAdjId. */
    let blockIds = resultBlockIds(pathsResultType, featurePaths[0]);
    if (blockIds.length) {
      /** blockAdjId is the order of Stacked / axes, whereas
       * featurePaths[0].alignment is in request order.
       * Requests (so far) are asymmetric, so blockAdjId[] and blockIds[] may be
       * in opposite order.
       */
      // const reversed = blockAdjId[0] > blockAdjId[1],
      function match(reversed) {
        let
          ok = (blockIds[0] === blockAdjId[0+reversed]) && (blockIds[1] === blockAdjId[1-reversed]);
        return ok;
      }
      let ok = match(false) || match(true);
      if (! ok)
        dLog('draw verify', blockAdjId, blockIds);
    }

    // let axisApi = this.get('drawMap.oa.axisApi');
    if (trace_blockAdj) {
      blockAdjId.forEach(function (blockId) {
        let axis = Stacked.getAxis(blockId);
        let aS = selectAxis(axis);
        dLog(blockId, aS.node());
      });
    }

    let dpS = progressGroupsSelect(pathsResultType.flowName);

    let baS = selectBlockAdj(dpS, blockAdjId);
    dLog(baS.nodes(), baS.node());
    
    if (baS.empty()) {
      dLog('draw', blockAdjId);
      promise = Promise.resolve();
    }
    else
    {
      let gS = baS.selectAll("g." + className)
        .data(featurePaths, pathsResultType.featurePathKeyFn);
      if (pathRemoveTransition) {
        gS.exit()
          .call(gPathDashAndRemove);
      } else {
        gS.exit().remove();
      }

      let gA = gS.enter()
        .append('g')
        .attr('id', featureGroupIdFn) 
        .attr('class', className)
      ;
      function featureGroupIdFn(featurePath) {
        let id = resultBlockIds(pathsResultType, featurePath);
        return blockAdjEltId(id) + '_' + pathsResultType.featureEltId(featurePath);
      }


      let gSA = gS.merge(gA),
      owner = getOwner(this),
      pS = gSA
        .selectAll("path." + className)
        .data(pathsOfFeature(store, pathsResultType, owner), locationPairKeyFn),
      pSE = pS.enter()
        .append("path")
        .attr("class", className)
      ;
      let pSA = pS.merge(pSE);

      let pathPosition = this.get('pathPosition');
      promise =
      /** existing paths (pS) are transitioned from their previous position;
       * the previous position of added paths is not easily available so they
       * are drawn without transition at their new position; this is done after
       * the transition of the paths already shown, so that the transformation
       * is consistent at any point in time, otherwise the movement is
       * confusing.
       */
      pathPosition.perform(pS)
        .then(/*pathPosition.perform(pSE)*/ () => pSE.call(this.attrD_pathU))
        .catch((error) => {
          // Recognise if the given task error is a TaskCancelation.
          if (! didCancel(error)) {
            dLog('draw pathPosition New taskInstance.catch', this.blockAdjId, error);
            throw error;
          }
        })
        ;//.then(() => { dLog('draw pathPosition then', pS.size(), pSE.size());  });

      if (pSE.size()) {
        const pathInfo = PathInfo(this.get('drawMap.oa'));
        pathInfo.setupMouseHover(pSE);
      }
      pS.exit().remove();
    }
    return promise;
  },

  /** Update the "d" attribute of the <path>-s.  */
  updatePathsPosition() {
    if (this.get('blockAdj.areSyntenyBlocks')) {
      let axisApi = this.get('drawMap.oa.axisApi');
      axisApi.updateSyntenyBlocksPosition();
      return;
    }

    // based on draw().
    let dpS = progressGroupsSelect(undefined);
    let blockAdjId = this.get('blockAdjId') || this.blockAdj.blockAdjId;
    if (trace_blockAdj > 1)
      blockAdjId.forEach(function (blockId) {
        let axis = Stacked.getAxis(blockId);
        let y = axis.y;
        dLog('updatePathsPosition axis', axis.axisName, y.domain(), y.range(), axis);
      });
    let baS = selectBlockAdj(dpS, blockAdjId);
    // let groupAddedClass = featurePaths[0]._id.name;
    //  + '.' + groupAddedClass
    let gS = baS.selectAll("g." + className),
    pS = gS
      .selectAll("path." + className);
    // Remove <path>s whose data refers to a block which has been removed from its axis.
    // later the block-adj will be removed, which will remove all contents.
   let removed = pS
      .filter(function (d) { return ! d.blocksHaveAxes(); });
    if (! removed.empty())
        dLog('updatePathsPosition removed', removed.nodes(), removed.node());
    removed.remove();
    pS = gS
      .selectAll("path." + className)
      // don't call pathU() if axes are gone.
      .filter(function (d) { return d.blocksHaveAxes(); });
    if (! pS.empty() && trace_blockAdj)
      dLog('updatePathsPosition before update pS', (trace_blockAdj > 1) ? pS.nodes() : pS.size(), pS.node());
    this.get('pathPosition').perform(pS)
        .catch((error) => {
          // Recognise if the given task error is a TaskCancelation.
          if (! didCancel(error)) {
            dLog('updatePathsPosition (pathPosition) New taskInstance.catch', this.blockAdjId, error);
            throw error;
          }
        })
        .then(() => { dLog('updatePathsPosition (pathPosition) then'); });
  },

  /** Calculate the path value.
   * @usage d3.selection ... .call(this.attrD_pathU)
   * @param pathSelection	d3 selection or transition of <path>
   */
  attrD_pathU(pathSelection) {
      // pathU() is temporarily a function, will revert to a computed function, as commented in path().
      pathSelection.attr("d", function(d) { return d.pathU() /*get('pathU')*/; });
  },
  /** Update position of the paths indicated by the selection.
   * Making this a task with .drop() enables avoiding conflicting transitions.
   * @param pathSelection
   * @return transitionEnd  promise of completion of render transition
   */
  pathPosition: task(function * (pathSelection) {
    dLog('pathPosition',  pathSelection.size());
    /** if the selection is empty, there's no point in waiting for the
     * transition, and also it looks like transition .on('end') doesn't trigger
     * when the selection is empty.
     */
    if (! pathSelection.size()) {
      return Promise.resolve();
    }
    /* Try selectionToTransition() instead.
    let throttleTime = this.get('controlsView.throttleTime'),
        pathTransitionTimeVar = throttleTime ? throttleTime * 1 : pathTransitionTime;
    */
    let
    /* now that paths are within <g.block-adj>, path position can be altered
     * during dragging by updating a skew transform of <g.block-adj>, instead of
     * repeatedly recalculating pathU.
     */
      transition = 
      this.get('axisZoom').selectionToTransition(pathSelection)
      // .transition().duration(pathTransitionTimeVar)
      .call(this.attrD_pathU)
    ;

    let transitionEnd;
    if (transition !== pathSelection) {
    /** in a later version of d3, can use 
     * transitionEnd = transition.end(); ... return transitionEnd;
     * instead of new Promise(...)
     * The caller is interested in avoiding overlapped transitions, so
     * resolve/reject are treated the same.
     */
     transitionEnd =  new Promise(function(resolve, reject){
       transition
         .on('end', (event, d) => resolve(d))
         .on('interrupt', (event, d) => {
           resolve(d);
           if (trace_blockAdj > 2) {
             dLog('interrupt', d); }; }); });  // also 'cancel', when version update
    if (trace_blockAdj) {
      dLog('pathPosition', pathSelection.node());
      transitionEnd.then(() => dLog('pathPosition end', pathSelection.node()));
    }
    }
    else
      /* no transition to wait for. */
    // try not waiting for completion of transition, combined with throttle on the caller.
    transitionEnd = Promise.resolve();

    return transitionEnd;
  }).keepLatest(),

  /** Call updateAxis() for the axes which bound this block-adj.
   * See comment in updatePathsPositionDebounce().
   */
  updateAxesScale() {
    let
      axes = this.get('axes'),
    /** reference blocks */
    axesBlocks = axes.mapBy('blocks');
    dLog('updateAxesScale', axesBlocks.map((blocks) => blocks.mapBy('axisName')));
    axesBlocks.forEach(function (blocks) {
      blocks[0].axis.updateAxis();
    });
  },

  /*--------------------------------------------------------------------------*/

  axesDomains : alias('blockAdj.axesDomains'),
  /** call updatePathsPosition().
   * filter / debounce the calls to handle multiple events at the same time.
   */
  updatePathsPositionDebounce : computed(
    'widthChanged',
    'heightChanged', 'axisStackChangedCount',
    // stacksWidthChanges depends on stacksCount, so this dependency is implied anyway.
    'block.stacksCount',
    // widthsSum includes changes to .extended, which impacts width of all block-adjs
    'block.stacksWidthsSum',
    'block.axesExtendedCount',
    'xOffsets.@each',
    'graphFrame.stacksWidthChanges',
    'blockAdj.axes1d.0.flipRegionCounter',
    'blockAdj.axes1d.1.flipRegionCounter',
    'blockAdj.axes1d.{0,1}.flipped',
    /* Paths end X position is affected when an adjacent axis opens/closes (split).  */
    'blockAdj.axes1d.{0,1}.extended',
    /* will change scaleChanged to return {range: [from,to], domain : [from, to]}
     * currently it returns the scale function itself which is not usable as a dependent key.
     * Then the dependency can be : 'blockAdj.axes1d.{0,1}.scaleChanged.range.{0,1}'
     * After domain change, the available paths should be filtered again, whereas
     * after range change, it is sufficient to update the position of those paths already rendered.
     */
    'blockAdj.axes1d.0.scaleChanged',
    'blockAdj.axes1d.1.scaleChanged',
    /* width of split axes affects the path endpoint x values, even if not adjacent.
     * There is a list of axes2d of all axes in stacksCount,
     * e.g. this.get('parentView.oa.stacks.stacksCount.axes2d.0.allocatedWidthsMax.centre').
     * but 'axes2d.@each.allocatedWidthsMax.centre' is not a valid dependency
     * because only 1 level is supported after @each.
     * If needed a CP for 'axes2d.@each.allocatedWidthsMax' could be added.
     * This dependency considers only the axes2d of this block-adj :
     */
    'blockAdj.axes1d.{0,1}.axis2d.allocatedWidthsMax.centre',
    function () {
      let count = this.get('axisStackChangedCount');
      // throttle(this, this.updatePathsPositionDebounced, this.get('controlsView.throttleTime'), true);
      run_once(() => this.updatePathsPosition());
      return count;
    }),
    updatePathsPositionDebounced : function () {
      let count = this.get('axisStackChangedCount'),
      stacksWidthChanges = this.get('graphFrame.stacksWidthChanges'),
      flips = [this.get('blockAdj.axes1d.0.flipRegionCounter'),
               this.get('blockAdj.axes1d.1.flipRegionCounter')],
      scaleChanges = [this.get('blockAdj.axes1d.0.scaleChanged'),
                      this.get('blockAdj.axes1d.1.scaleChanged')],
      zoomCounter = this.get('blockAdj.zoomCounter'),
      heightChanged = this.get('heightChanged');
      if (trace_blockAdj)
        dLog('updatePathsPositionDebounce', this.get('blockAdjId'), heightChanged, count, flips, zoomCounter, scaleChanges,
           stacksWidthChanges,
           this.get('xOffsets'),
           this.get('block.stacksCount'));
    this.updatePathsPosition();
    /* redraw after axis extended width has updated. */
    // later(() => this.updatePathsPosition(), 500);

      /* this update is an alternative trigger for updating the axes ticks and
       * scale when their domains change, e.g. when loaded features extend a
       * block's domain.  The solution used instead is the ComputedProperty
       * side-effect axis-1d : domainChanged(), which is a similar approach, but
       * it localises the dependencies to a single axis whereas this would
       * duplicate updates.  */
    // this.updateAxesScale();
    return count;
  },


  /*--------------------------------------------------------------------------*/
  
  /** block-adj receives axisStackChanged and zoomedAxis from draw-map
   */

  resized : function(widthChanged, heightChanged, useTransition) {
    /* useTransition could be passed down to draw()
     * (also could pass in duration or t from showResize()).
     */
    if (trace_blockAdj > 1)
      dLog("resized in components/block-adj");
    /* In addition to the usual causes of repeated events, block-adj will
     * respond to events relating to 2 axes. */
    if (widthChanged)
      this.incrementProperty('widthChanged');
    if (heightChanged)
      this.incrementProperty('heightChanged');
  },

  axisStackChanged : function() {
    dLog("axisStackChanged in components/block-adj");
    // currently need time for x scale update
    next(() => ! this.isDestroying && this.incrementProperty('axisStackChangedCount'));
  },

  /** @param [axisID, t] */
  zoomedAxis : function(axisID_t) {
    let axisID = axisID_t[0],
    blockAdjId = this.get('blockAdjId'),
    axes = this.get('axes');
    if (trace_blockAdj > 1)
      dLog("zoomedAxis in ", CompName, axisID_t, blockAdjId, axes);
    /* zoomedAxis is specific to an axisID, so respond to that if
     * blockAdjId[0] or blockAdjId[1] are on this.axis.
     * resetZooms() does resetZoom(undefined) meaning un-zoom all axes, so match
     * if axisID is undefined.
     */
    if (!axisID || this.isAdjacentToAxis(axisID))
    {
      dLog('zoomedAxis matched', axisID, blockAdjId, axes);
      // paths positions are updated by event axisStackChanged() already received.
      // With zoom, the densityCount() result changes so request paths again
      this.incrementProperty('blockAdj.zoomCounter');
    }
  }
  /*--------------------------------------------------------------------------*/

  
}); // end of Component draw/block-adj


/*----------------------------------------------------------------------------*/

/** Transition the paths in the given g, to show that they are being removed.
 * @param g <g.blockAdj> which is to be removed, and contains <path.blockAdj>-s
 */
function gPathDashAndRemove(g) {
  /** selector 'path' is equivalent here to : 'g.blockAdj > path.blockAdj' */
  let exitPaths = g
    .transition().duration(pathTransitionTime * 3)
    .on('end', function() { d3.select(this).remove(); })
    .selectAll('path')
    .call(pathDashTween(true));
}

/* transition the stroke-dasharray, to show paths being added and removed. */

/* This could also be used on path exit,   e.g. :
 * pS.exit()
 *      .transition().duration(pathTransitionTime)
 *      .call(pathDashTween(true))
 *      .each("end", function() { d3.select(this).remove(); });
 * but generally this remove will not be reached because the parent <g> is
 * removed, and the transition is already applied on the gS.exit().
 *
 * This transition could also be applied on path append :
 *   pSE
 *     .transition().duration(pathTransitionTime * 3)
 *     .call(this.attrD_pathU)
 *     .call(pathTween(false))
 *     .each("end", function() { d3.select(this).attr("stroke-dasharray", 'none'); });
 * pSE would have to be separated out of transition on pSA, to avoid conflict.
 */

/** Return a function which interpolates stroke-dasharray,
 * to show a path going from visible to invible (if out is true) or vice versa.
 */
function pathDashTween(out) {
  function tweenDash() {
    /* based on example https://bl.ocks.org/mbostock/5649592 */
    /** if length is not yet known, use 20px, otherwise 1/20 of length. */
    var l = (this.getTotalLength() / 20) || 20,
    dashStrings = [
      l + "," + 0,          // visible
      "0," + l + l/4],      // invisible
    from = dashStrings[+ !out],
    to = dashStrings[+ out],
    i = d3.interpolateString(from, to);
    return function(t) { return i(t); };
  }

  return function (path) {
  path
      .attrTween("stroke-dasharray", tweenDash);
  };
}



/*----------------------------------------------------------------------------*/
